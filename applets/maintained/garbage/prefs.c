/* prefs.c generated by valac, the Vala compiler
 * generated from prefs.vala, do not modify */

/*
 * Preferences dialog for the Garbage applet.
 *
 * Copyright (C) 2009 Mark Lee <avant-wn@lazymalevolence.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.
 *
 * Author : Mark Lee <avant-wn@lazymalevolence.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <libawn/libawn.h>
#include <glib/gi18n.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_GARBAGE_PREFS (garbage_prefs_get_type ())
#define GARBAGE_PREFS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GARBAGE_PREFS, GarbagePrefs))
#define GARBAGE_PREFS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GARBAGE_PREFS, GarbagePrefsClass))
#define IS_GARBAGE_PREFS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GARBAGE_PREFS))
#define IS_GARBAGE_PREFS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GARBAGE_PREFS))
#define GARBAGE_PREFS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GARBAGE_PREFS, GarbagePrefsClass))

typedef struct _GarbagePrefs GarbagePrefs;
typedef struct _GarbagePrefsClass GarbagePrefsClass;
typedef struct _GarbagePrefsPrivate GarbagePrefsPrivate;

#define TYPE_GARBAGE_APPLET (garbage_applet_get_type ())
#define GARBAGE_APPLET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GARBAGE_APPLET, GarbageApplet))
#define GARBAGE_APPLET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GARBAGE_APPLET, GarbageAppletClass))
#define IS_GARBAGE_APPLET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GARBAGE_APPLET))
#define IS_GARBAGE_APPLET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GARBAGE_APPLET))
#define GARBAGE_APPLET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GARBAGE_APPLET, GarbageAppletClass))

typedef struct _GarbageApplet GarbageApplet;
typedef struct _GarbageAppletClass GarbageAppletClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _GarbagePrefs {
	GtkDialog parent_instance;
	GarbagePrefsPrivate * priv;
};

struct _GarbagePrefsClass {
	GtkDialogClass parent_class;
};

struct _GarbagePrefsPrivate {
	GarbageApplet* _applet;
};


static gpointer garbage_prefs_parent_class = NULL;

GType garbage_prefs_get_type (void);
GType garbage_applet_get_type (void);
#define GARBAGE_PREFS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GARBAGE_PREFS, GarbagePrefsPrivate))
enum  {
	GARBAGE_PREFS_DUMMY_PROPERTY
};
static void garbage_prefs_create_ui (GarbagePrefs* self);
GarbagePrefs* garbage_prefs_new (GarbageApplet* applet);
GarbagePrefs* garbage_prefs_construct (GType object_type, GarbageApplet* applet);
gboolean garbage_applet_get_confirm_empty (GarbageApplet* self);
static void garbage_prefs_on_empty_toggled (GarbagePrefs* self, GtkToggleButton* button);
static void _garbage_prefs_on_empty_toggled_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
gboolean garbage_applet_get_show_count (GarbageApplet* self);
static void garbage_prefs_on_count_toggled (GarbagePrefs* self, GtkToggleButton* button);
static void _garbage_prefs_on_count_toggled_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void garbage_prefs_on_response (GarbagePrefs* self, gint response_id);
static void _garbage_prefs_on_response_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
void garbage_applet_set_confirm_empty (GarbageApplet* self, gboolean value);
void garbage_applet_set_show_count (GarbageApplet* self, gboolean value);
static void garbage_prefs_finalize (GObject* obj);



static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GarbagePrefs* garbage_prefs_construct (GType object_type, GarbageApplet* applet) {
	GParameter * __params;
	GParameter * __params_it;
	GarbagePrefs * self;
	char* _tmp2_;
	char* _tmp1_;
	char* _tmp0_ = NULL;
	GarbageApplet* _tmp3_;
	g_return_val_if_fail (applet != NULL, NULL);
	__params = g_new0 (GParameter, 1);
	__params_it = __params;
	__params_it->name = "type";
	g_value_init (&__params_it->value, GTK_TYPE_WINDOW_TYPE);
	g_value_set_enum (&__params_it->value, GTK_WINDOW_TOPLEVEL);
	__params_it++;
	self = g_object_newv (object_type, __params_it - __params, __params);
	gtk_window_set_title ((GtkWindow*) self, _tmp2_ = g_strdup_printf (_ ("%s Preferences"), _tmp1_ = (g_object_get ((AwnApplet*) applet, "display-name", &_tmp0_, NULL), _tmp0_)));
	_g_free0 (_tmp2_);
	_g_free0 (_tmp1_);
	gtk_window_set_icon_name ((GtkWindow*) self, "gtk-preferences");
	self->priv->_applet = (_tmp3_ = _g_object_ref0 (applet), _g_object_unref0 (self->priv->_applet), _tmp3_);
	garbage_prefs_create_ui (self);
	while (__params_it > __params) {
		--__params_it;
		g_value_unset (&__params_it->value);
	}
	g_free (__params);
	return self;
}


GarbagePrefs* garbage_prefs_new (GarbageApplet* applet) {
	return garbage_prefs_construct (TYPE_GARBAGE_PREFS, applet);
}


static void _garbage_prefs_on_empty_toggled_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	garbage_prefs_on_empty_toggled (self, _sender);
}


static void _garbage_prefs_on_count_toggled_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	garbage_prefs_on_count_toggled (self, _sender);
}


static void _garbage_prefs_on_response_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	garbage_prefs_on_response (self, response_id);
}


static void garbage_prefs_create_ui (GarbagePrefs* self) {
	GtkCheckButton* empty_button;
	GtkCheckButton* count_button;
	GtkCheckButton* _tmp0_;
	GtkCheckButton* _tmp1_;
	g_return_if_fail (self != NULL);
	empty_button = NULL;
	count_button = NULL;
	gtk_box_set_spacing ((GtkBox*) ((GtkDialog*) self)->vbox, 5);
	empty_button = (_tmp0_ = g_object_ref_sink ((GtkCheckButton*) gtk_check_button_new_with_mnemonic (_ ("Confirm when emptying the trash"))), _g_object_unref0 (empty_button), _tmp0_);
	gtk_toggle_button_set_active ((GtkToggleButton*) empty_button, garbage_applet_get_confirm_empty (self->priv->_applet));
	g_signal_connect_object ((GtkToggleButton*) empty_button, "toggled", (GCallback) _garbage_prefs_on_empty_toggled_gtk_toggle_button_toggled, self, 0);
	gtk_container_add ((GtkContainer*) ((GtkDialog*) self)->vbox, (GtkWidget*) empty_button);
	count_button = (_tmp1_ = g_object_ref_sink ((GtkCheckButton*) gtk_check_button_new_with_mnemonic (_ ("Show the item count on the icon"))), _g_object_unref0 (count_button), _tmp1_);
	gtk_toggle_button_set_active ((GtkToggleButton*) count_button, garbage_applet_get_show_count (self->priv->_applet));
	g_signal_connect_object ((GtkToggleButton*) count_button, "toggled", (GCallback) _garbage_prefs_on_count_toggled_gtk_toggle_button_toggled, self, 0);
	gtk_container_add ((GtkContainer*) ((GtkDialog*) self)->vbox, (GtkWidget*) count_button);
	gtk_dialog_add_button ((GtkDialog*) self, GTK_STOCK_CLOSE, (gint) GTK_RESPONSE_CLOSE);
	g_signal_connect_object ((GtkDialog*) self, "response", (GCallback) _garbage_prefs_on_response_gtk_dialog_response, self, 0);
	_g_object_unref0 (empty_button);
	_g_object_unref0 (count_button);
}


static void garbage_prefs_on_empty_toggled (GarbagePrefs* self, GtkToggleButton* button) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	garbage_applet_set_confirm_empty (self->priv->_applet, gtk_toggle_button_get_active (button));
}


static void garbage_prefs_on_count_toggled (GarbagePrefs* self, GtkToggleButton* button) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	garbage_applet_set_show_count (self->priv->_applet, gtk_toggle_button_get_active (button));
}


static void garbage_prefs_on_response (GarbagePrefs* self, gint response_id) {
	g_return_if_fail (self != NULL);
	gtk_widget_hide ((GtkWidget*) self);
}


static void garbage_prefs_class_init (GarbagePrefsClass * klass) {
	garbage_prefs_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GarbagePrefsPrivate));
	G_OBJECT_CLASS (klass)->finalize = garbage_prefs_finalize;
}


static void garbage_prefs_instance_init (GarbagePrefs * self) {
	self->priv = GARBAGE_PREFS_GET_PRIVATE (self);
}


static void garbage_prefs_finalize (GObject* obj) {
	GarbagePrefs * self;
	self = GARBAGE_PREFS (obj);
	_g_object_unref0 (self->priv->_applet);
	G_OBJECT_CLASS (garbage_prefs_parent_class)->finalize (obj);
}


GType garbage_prefs_get_type (void) {
	static volatile gsize garbage_prefs_type_id__volatile = 0;
	if (g_once_init_enter (&garbage_prefs_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GarbagePrefsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) garbage_prefs_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GarbagePrefs), 0, (GInstanceInitFunc) garbage_prefs_instance_init, NULL };
		GType garbage_prefs_type_id;
		garbage_prefs_type_id = g_type_register_static (GTK_TYPE_DIALOG, "GarbagePrefs", &g_define_type_info, 0);
		g_once_init_leave (&garbage_prefs_type_id__volatile, garbage_prefs_type_id);
	}
	return garbage_prefs_type_id__volatile;
}




